import {
    recordPatches,
    IPatchRecorder,
    createActionTrackingMiddleware2, flow,
    addMiddleware,
    addDisposer, isActionContextThisOrChildOf, IActionTrackingMiddleware2Call, Instance
} from "mobx-state-tree";
import { v4 as uuidv4 } from "uuid";
import { ContainerAPI, TreeChangeEntry } from "../container-api";
import { Tree } from "../tree";

interface CallEnv {
    recorder: IPatchRecorder;
    sharedModelModifications: SharedModelModifications;
    containerActionId: string;
}

// A map of shared model paths to their update functions
type SharedModelChangeHandler = (containerActionId: string, call: IActionTrackingMiddleware2Call<CallEnv>) => void;
export type SharedModelsConfig = Record<string, SharedModelChangeHandler>;
type SharedModelModifications = Record<string, number>;

// This seems to work better not being an MST model, it doesn't
// need to record state its self. 
export const createUndoRecorder = (tree: Instance<typeof Tree>, container: ContainerAPI, 
    includeHooks: boolean, sharedModelsConfig: SharedModelsConfig = {}) => {
    let recordingDisabled = 0;

    const undoRedoMiddleware = createActionTrackingMiddleware2<CallEnv>({
        filter(call) {
            if (call.env) {
                // already recording
                return false;
            }
            return true;
        },
        onStart(call) {
            const sharedModelPaths = Object.keys(sharedModelsConfig);
            const sharedModelModifications: SharedModelModifications = {};

            // Initialize how we record the shared model changes
            sharedModelPaths.forEach((path) => sharedModelModifications[path] = 0);

            let containerActionId;

            // TODO: this seems like a bit of a hack. We are looking for specific actions
            // which we know include a containerActionId as their first argument
            // this is so we can link all of the changes with this same containerActionId
            // These actions are all defined on the common `Tree` model which is
            // composed into the actual tiles and shared models. So at least
            // the specific trees are not defining these actions themselves.
            //
            // I can't think of a better way so far. 
            // If a function in this middleware could apply the snapshots and run the 
            // syncing that would let us directly pass in the containerActionId. However
            // we still need to record the changes in the undo history. So we still need
            // this to pass through as an action so the middleware can record it.
            //
            // We could use the `decorate` feature of MST to at least make it more clear
            // in the Tile model that these actions are special. 
            if (call.name === "applySharedModelSnapshotFromContainer" ||
                call.name === "updateTreeAfterSharedModelChangesInternal") {
                containerActionId = call.args[0];
            } else {
               containerActionId = uuidv4();
            }

            const recorder = recordPatches(
                call.tree,
                (_patch, _inversePatch, actionContext) => {
                    if (recordingDisabled) {
                        return false;
                    }

                    // See if the patch is modifying one of the mounted shared model views
                    // If it is then don't record this patch, and also track the modification
                    // so we can notify the tree when the action is done.
                    // The tree needs to know about these modifications so it can update
                    // itself from changes in the shared model view, and so it can send these
                    // changes to the container.
                    if (sharedModelsConfig) {
                        const sharedModelPath = sharedModelPaths.find((path) => _patch.path.startsWith(path));
                        if (sharedModelPath) {
                            // increment the number of modifications made to the shared model
                            sharedModelModifications[sharedModelPath]++;
                            // don't record this patch because it will be recorded by the shared model itself
                            return false;
                        }
                    }

                    // only record patches that were generated by this action or children of this action
                    return (
                        !!actionContext && isActionContextThisOrChildOf(actionContext, call.id)
                    );
                }
            );
            recorder.resume();

            call.env = {
                recorder,
                sharedModelModifications,
                containerActionId
            };
        },
        onFinish(call, error) {
            const { recorder, sharedModelModifications, containerActionId } = call.env || {};
            if (!recorder || !sharedModelModifications || !containerActionId) {
                throw new Error("The call.env is corrupted");
            }
            call.env = undefined;
            recorder.stop();

            if (error === undefined) {
                const undoableAction = call.name !== "applyPatchesFromUndo";
                addUndoState(recorder, call.name, containerActionId, undoableAction);
                // Call the shared model notification function if there are changes. 
                // This is needed so the changes can be sent to the container,
                // and so the changes can trigger a update/sync of the tile model
                // Previously this internal updating or sync'ing was done using an autorun to monitor the models. 
                // But that doesn't have access to the action id that triggered the sync, and that action id is
                // needed so we can group the changes together so we can undo them later.
                Object.entries(sharedModelModifications).forEach(([path, numModifications]) => {
                    if (numModifications > 0) {
                        // Run the callback tracking changes to the shared model
                        sharedModelsConfig[path](containerActionId, call);
                    }
                });
            } else {
                // TODO: This is kind of a new feature that is being added to the tree by the undo manager
                // any errors that happen during an action will cause the tree to revert back to 
                // how it was before. 
                // This might be a good thing to do, but it needs to be analysed to see what happens
                // with the shared models when the patches are undone.
                recorder.undo();
            }
        }
    });

    /**
     * This is used both internally to skip recording the undo and redo actions, and
     * to allow code using this middle ware to skip certain actions.
     *
     * The internal actions modify the recorded tree, so they should be skipped for
     * purposes of undo. However, in order to support time travel that includes undo
     * and redo we will need to record them somewhere, but perhaps that would be a
     * separate middleware.
     *
     * The `recordingDisabled` counter is used above in onStart in its recordPatches
     * callback. Note that this is global setting. So if something starts skipping
     * recording that would be applied to all actions even un related asynchronous
     * ones.
     */
    const skipRecording = <T>(fn: () => T): T => {
        recordingDisabled++;
        try {
            return fn();
        } finally {
            recordingDisabled--;
        }
    };

    // I'd guess in our case we always want to include hooks. If a model makes some 
    // changes to its state when it is added to the tree during an action we'd want that
    // to be part of the undo stack.  
    //
    // TODO: however perhaps this setting is just for the initial action. So perhaps even
    // without this the creation of a model would be recorded by the recorder if it was
    // a done in a child action. So we should do some experimentation with middleware
    // the recorder and hooks.
    const middlewareDisposer = addMiddleware(tree, undoRedoMiddleware, includeHooks);

    // We might need an option to not add this disposer, but it seems it would generally
    // ge a good thing to do.
    addDisposer(tree, middlewareDisposer);

    const addUndoState = (recorder: IPatchRecorder, actionName: string, 
        containerActionId: string, undoableAction: boolean) => {
        if (recorder.patches.length === 0) {
            // skip recording if patches is empty
            return;
        }

        // Send new entry to the container
        const treeChangeEntry: TreeChangeEntry = {
            treeId: tree.id,
            actionName,
            patches: recorder.patches,
            inversePatches: recorder.inversePatches,
        };
        console.log("recording undoable action", treeChangeEntry);
        container.recordChangeEntry(containerActionId, treeChangeEntry, undoableAction);
    };

    return {
        middlewareDisposer,

        withoutUndo<T>(fn: () => T): T {
            return skipRecording(fn);
        },
        withoutUndoFlow(generatorFn: () => any) {
            return flow(function* __withoutUndoFlow__() {
                recordingDisabled++;
                try {
                    return yield* generatorFn();
                } finally {
                    recordingDisabled--;
                }
            });
        },
    };
};
