// This started from the undo-manager in mst-middlewares
import {
    types,
    IJsonPatch,
    IAnyStateTreeNode,
    recordPatches,
    IPatchRecorder,
    createActionTrackingMiddleware2,
    getEnv,
    getRoot,
    applyPatch,
    flow,
    addMiddleware,
    addDisposer,
    decorate,
    isActionContextThisOrChildOf
} from "mobx-state-tree";
import atomic from "./atomic";

const Entry = types.model("UndoManagerEntry", {
    patches: types.frozen<ReadonlyArray<IJsonPatch>>(),
    inversePatches: types.frozen<ReadonlyArray<IJsonPatch>>()
});

const UndoManager = types
    .model("UndoManager", {
        history: types.array(Entry),
        undoIdx: 0
    })
    .views((self) => ({
        get undoLevels() {
            return self.undoIdx;
        },
        get redoLevels() {
            return self.history.length - self.undoIdx;
        },
        get canUndo() {
            return this.undoLevels > 0;
        },
        get canRedo() {
            return this.redoLevels > 0;
        }
    }))
    .actions((self) => {
        let includeHooks = false;
        let targetStore: IAnyStateTreeNode;
        let recordingDisabled = 0;

        interface Context {
            recorder: IPatchRecorder
        }

        type GroupRecorder = Pick<IPatchRecorder, "patches" | "inversePatches">
        // This is essentially a global variable for tracking the group recorders
        // To start simple I'm going to remove this feature
        const groupRecorders: GroupRecorder[] = [];

        const undoRedoMiddleware = createActionTrackingMiddleware2<Context>({
            filter(call) {
                if (call.env) {
                    // already recording
                    return false;
                }
                if (call.context === self) {
                    // also skip actions on ourselves, the undo manager
                    return false;
                }

                return true;
            },
            onStart(call) {
                const recorder = recordPatches(
                    call.tree,
                    (_patch, _inversePatch, actionContext) => {
                        if (recordingDisabled) {
                            return false;
                        }
                        // only record patches that were generated by this action or children of this action
                        return (
                            !!actionContext && isActionContextThisOrChildOf(actionContext, call.id)
                        );
                    }
                );
                recorder.resume();
                call.env = {
                    recorder
                };
            },
            onFinish(call, error) {
                const recorder = call.env!.recorder;
                call.env = undefined;
                recorder.stop();

                if (error === undefined) {
                    // To start simple I'm going to remove this feature
                    if (groupRecorders.length > 0) {
                        const groupRecorder = groupRecorders[groupRecorders.length - 1];
                        groupRecorder.patches = groupRecorder.patches.concat(recorder.patches);
                        groupRecorder.inversePatches = groupRecorder.inversePatches.concat(
                            recorder.inversePatches
                        );
                    } else {
                        (self as any).addUndoState(recorder);
                    }
                } else {
                    recorder.undo();
                }
            }
        });

        /**
         * This is used both internally to skip recording the undo and redo actions, and
         * to allow code using this middle ware to skip certain actions. 
         * 
         * The internal actions modify the recorded tree, so they should be skipped for 
         * purposes of undo. However, in order to support time travel that includes undo 
         * and redo we will need to record them somewhere, but perhaps that would be a 
         * separate middleware.
         * 
         * The `recordingDisabled` counter is used above in onStart in its recordPatches 
         * callback. Note that this is global setting. So if something starts skipping
         * recording that would be applied to all actions even un related asynchronous 
         * ones. 
         */
        const skipRecording = <T>(fn: () => T): T => {
            recordingDisabled++;
            try {
                return fn();
            } finally {
                recordingDisabled--;
            }
        };

        return {
            addUndoState(recorder: GroupRecorder) {
                // Why withoutUndo is used here, but skipRecording is used elsewhere doesn't
                // seem to make much sense, they both do the same thing. However withoutUndo
                // is an actual action, so perhaps that matters?
                this.withoutUndo(() => {
                    if (recorder.patches.length === 0) {
                        // skip recording if patches is empty
                        return;
                    }
                    // This is a new user action, so if they had undone some amount
                    // we delete that part of the history past this point
                    self.history.splice(self.undoIdx);
                    // Add a new entry with the patches and inverse patches
                    // it would be useful to record the name of the action here too 
                    self.history.push({
                        patches: recorder.patches,
                        inversePatches: recorder.inversePatches
                    });                    
                    const maxLength = getEnv(self).maxHistoryLength || Infinity;
                    // delete items from the beginning of the history so the total is maxLength
                    self.history.splice(0, self.history.length - maxLength);
                    // reset the undoIdx to the end of the history, this is because it is a 
                    // new user action so anything past this point can no longer be redone
                    self.undoIdx = self.history.length;
                });
            },
            afterCreate() {
                // currently supports two options for integration:
                // 1. as a separate tree and using targetStore to tell the part of the tree to manage
                // 2. or as a sub part of the tree being recorded
                const selfRoot = getRoot(self);
                targetStore = getEnv(self).targetStore || selfRoot;
                if (targetStore === self) {
                    throw new Error(
                        "UndoManager should be created as part of a tree, or with `targetStore` in it's environment"
                    );
                }

                if (typeof getEnv(self).includeHooks === "boolean") {
                    includeHooks = getEnv(self).includeHooks;
                }

                // I'd guess in our case we always want to include hooks. If a model makes some 
                // changes to its state when it is added to the tree during an action we'd want that
                // to be part of the undo stack.  
                //
                // TODO: however perhaps this setting is just for the initial action. So perhaps even
                // without this the creation of a model would be recorded by the recorder if it was
                // a done in a child action. So we should do some experimenation with middleware
                // the recorder and hooks.
                addDisposer(self, addMiddleware(targetStore, undoRedoMiddleware, includeHooks));
            },
            undo: decorate(atomic, () => {
                skipRecording(() => {
                    if (!self.canUndo) {
                        throw new Error("undo not possible, nothing to undo");
                    }
                    // Note this is actually applying the array of patches associated with the 
                    // the last action
                    applyPatch(
                        getRoot(targetStore),
                        // n.b: reverse patches back to forth
                        // the slice is used to copy the patches array so it can
                        // be reversed in place with reverse.
                        self.history[self.undoIdx - 1].inversePatches.slice().reverse()
                    );
                    self.undoIdx--;
                });
            }),
            redo: decorate(atomic, () => {
                skipRecording(() => {
                    if (!self.canRedo) {
                        throw new Error("redo not possible, nothing to redo");
                    }
                    applyPatch(getRoot(targetStore), self.history[self.undoIdx].patches);
                    self.undoIdx++;
                });
            }),
            withoutUndo<T>(fn: () => T): T {
                return skipRecording(fn);
            },
            withoutUndoFlow(generatorFn: () => any) {
                return flow(function* __withoutUndoFlow__() {
                    recordingDisabled++;
                    try {
                        return yield* generatorFn();
                    } finally {
                        recordingDisabled--;
                    }
                });
            },
            // I'll disable this for now until we need it
            startGroup<T>(fn: () => T): T {
                if (groupRecorders.length >= 1) {
                    throw new Error(
                        "a previous startGroup is still running, did you forget to call stopGroup?"
                    );
                }
                groupRecorders.push({
                    patches: [],
                    inversePatches: []
                });
                return fn();
            },
            // I'll disable this for now until we need it
            stopGroup() {
                const groupRecorder = groupRecorders.pop();
                if (!groupRecorder) {
                    throw new Error(
                        "each call to stopGroup requires a previous call to startGroup, did you forget to call startGroup?"
                    );
                }
                this.addUndoState(groupRecorder);
            },
            clear: decorate(atomic, () => {
                skipRecording(() => {
                    self.history.clear();
                    self.undoIdx = 0;
                });
            }),
            clearUndo: decorate(atomic, () => {
                skipRecording(() => {
                    self.history.splice(0, self.undoLevels);
                    self.undoIdx = 0;
                });
            }),
            clearRedo: decorate(atomic, () => {
                skipRecording(() => {
                    self.history.splice(self.undoIdx, self.redoLevels);
                });
            })
        };
    });

export default UndoManager;
