// This started from the undo-manager in mst-middlewares
import {
    types,
    IJsonPatch,
    IAnyStateTreeNode,
    recordPatches,
    IPatchRecorder,
    createActionTrackingMiddleware2,
    getEnv,
    getRoot,
    applyPatch,
    flow,
    addMiddleware,
    addDisposer,
    decorate,
    isActionContextThisOrChildOf
} from "mobx-state-tree";
import atomic from "./atomic";

const Entry = types.model("UndoManagerEntry", {
    actionName: types.string,
    patches: types.frozen<ReadonlyArray<IJsonPatch>>(),
    inversePatches: types.frozen<ReadonlyArray<IJsonPatch>>()
});

export const UndoManager = types
    .model("UndoManager", {
        history: types.array(Entry),
        undoIdx: 0
    })
    .views((self) => ({
        get undoLevels() {
            return self.undoIdx;
        },
        get redoLevels() {
            return self.history.length - self.undoIdx;
        },
        get canUndo() {
            return this.undoLevels > 0;
        },
        get canRedo() {
            return this.redoLevels > 0;
        }
    }))
    .actions((self) => {
        let includeHooks = false;
        let targetStore: IAnyStateTreeNode;
        let recordingDisabled = 0;

        interface Context {
            recorder: IPatchRecorder
        }

        const undoRedoMiddleware = createActionTrackingMiddleware2<Context>({
            filter(call) {
                if (call.env) {
                    // already recording
                    return false;
                }
                if (call.context === self) {
                    // also skip actions on ourselves, the undo manager
                    return false;
                }

                return true;
            },
            onStart(call) {
                const recorder = recordPatches(
                    call.tree,
                    (_patch, _inversePatch, actionContext) => {
                        if (recordingDisabled) {
                            return false;
                        }

                        // Filter out patches that are modifying the exclude path. 
                        const excludePath = getEnv(self).excludePath;
                        if (_patch.path.match(excludePath)) {
                            return false;
                        }

                        // only record patches that were generated by this action or children of this action
                        return (
                            !!actionContext && isActionContextThisOrChildOf(actionContext, call.id)
                        );
                    }
                );
                recorder.resume();
                call.env = {
                    recorder
                };
            },
            onFinish(call, error) {
                const recorder = call.env?.recorder;
                if (!recorder) {
                    throw new Error("The call.env is corrupted");
                }
                call.env = undefined;
                recorder.stop();

                if (error === undefined) {
                    (self as any).addUndoState(recorder, call.name);
                } else {
                    recorder.undo();
                }
            }
        });

        /**
         * This is used both internally to skip recording the undo and redo actions, and
         * to allow code using this middle ware to skip certain actions. 
         * 
         * The internal actions modify the recorded tree, so they should be skipped for 
         * purposes of undo. However, in order to support time travel that includes undo 
         * and redo we will need to record them somewhere, but perhaps that would be a 
         * separate middleware.
         * 
         * The `recordingDisabled` counter is used above in onStart in its recordPatches 
         * callback. Note that this is global setting. So if something starts skipping
         * recording that would be applied to all actions even un related asynchronous 
         * ones. 
         */
        const skipRecording = <T>(fn: () => T): T => {
            recordingDisabled++;
            try {
                return fn();
            } finally {
                recordingDisabled--;
            }
        };

        return {
            addUndoState(recorder: IPatchRecorder, actionName: string) {
                // Why withoutUndo is used here, but skipRecording is used elsewhere doesn't
                // seem to make much sense, they both do the same thing. However withoutUndo
                // is an actual action, so perhaps that matters?
                this.withoutUndo(() => {
                    if (recorder.patches.length === 0) {
                        // skip recording if patches is empty
                        return;
                    }
                    // This is a new user action, so if they had undone some amount
                    // we delete that part of the history past this point
                    self.history.splice(self.undoIdx);
                    // Add a new entry with the patches and inverse patches
                    // it would be useful to record the name of the action here too 
                    self.history.push({
                        actionName,
                        patches: recorder.patches,
                        inversePatches: recorder.inversePatches
                    });                    
                    const maxLength = getEnv(self).maxHistoryLength || Infinity;
                    // delete items from the beginning of the history so the total is maxLength
                    self.history.splice(0, self.history.length - maxLength);
                    // reset the undoIdx to the end of the history, this is because it is a 
                    // new user action so anything past this point can no longer be redone
                    self.undoIdx = self.history.length;
                });
            },
            afterCreate() {
                // currently supports two options for integration:
                // 1. as a separate tree and using targetStore to tell the part of the tree to manage
                // 2. or as a sub part of the tree being recorded
                const selfRoot = getRoot(self);
                targetStore = getEnv(self).targetStore || selfRoot;
                if (targetStore === self) {
                    throw new Error(
                        "UndoManager should be created as part of a tree, or with `targetStore` in it's environment"
                    );
                }

                if (typeof getEnv(self).includeHooks === "boolean") {
                    includeHooks = getEnv(self).includeHooks;
                }

                // I'd guess in our case we always want to include hooks. If a model makes some 
                // changes to its state when it is added to the tree during an action we'd want that
                // to be part of the undo stack.  
                //
                // TODO: however perhaps this setting is just for the initial action. So perhaps even
                // without this the creation of a model would be recorded by the recorder if it was
                // a done in a child action. So we should do some experimenation with middleware
                // the recorder and hooks.
                addDisposer(self, addMiddleware(targetStore, undoRedoMiddleware, includeHooks));
            },
            undo: decorate(atomic, () => {
                skipRecording(() => {
                    if (!self.canUndo) {
                        throw new Error("undo not possible, nothing to undo");
                    }
                    // Note this is actually applying the array of patches associated with the 
                    // the last action
                    applyPatch(
                        getRoot(targetStore),
                        // n.b: reverse patches back to forth
                        // the slice is used to copy the patches array so it can
                        // be reversed in place with reverse.
                        self.history[self.undoIdx - 1].inversePatches.slice().reverse()
                    );
                    self.undoIdx--;
                });
            }),
            redo: decorate(atomic, () => {
                skipRecording(() => {
                    if (!self.canRedo) {
                        throw new Error("redo not possible, nothing to redo");
                    }
                    applyPatch(getRoot(targetStore), self.history[self.undoIdx].patches);
                    self.undoIdx++;
                });
            }),
            withoutUndo<T>(fn: () => T): T {
                return skipRecording(fn);
            },
            withoutUndoFlow(generatorFn: () => any) {
                return flow(function* __withoutUndoFlow__() {
                    recordingDisabled++;
                    try {
                        return yield* generatorFn();
                    } finally {
                        recordingDisabled--;
                    }
                });
            },
            clear: decorate(atomic, () => {
                skipRecording(() => {
                    self.history.clear();
                    self.undoIdx = 0;
                });
            }),
            clearUndo: decorate(atomic, () => {
                skipRecording(() => {
                    self.history.splice(0, self.undoLevels);
                    self.undoIdx = 0;
                });
            }),
            clearRedo: decorate(atomic, () => {
                skipRecording(() => {
                    self.history.splice(self.undoIdx, self.redoLevels);
                });
            })
        };
    });

interface RecordedEntry {
    actionName: string,
    patches: ReadonlyArray<IJsonPatch>,
    inversePatches: ReadonlyArray<IJsonPatch>
}
    
// I'm not sure this should be a MST model or not yet
export const createUndoRecorder = 
    (targetStore: IAnyStateTreeNode, onRecorded: (entry: RecordedEntry) => void, 
    includeHooks: boolean, excludePath: RegExp | undefined) => {
        let recordingDisabled = 0;

        interface Context {
            recorder: IPatchRecorder
        }

        const undoRedoMiddleware = createActionTrackingMiddleware2<Context>({
            filter(call) {
                if (call.env) {
                    // already recording
                    return false;
                }
                return true;
            },
            onStart(call) {
                const recorder = recordPatches(
                    call.tree,
                    (_patch, _inversePatch, actionContext) => {
                        if (recordingDisabled) {
                            return false;
                        }

                        // Filter out patches that are modifying the exclude path. 
                        if (excludePath && _patch.path.match(excludePath)) {
                            return false;
                        }

                        // only record patches that were generated by this action or children of this action
                        return (
                            !!actionContext && isActionContextThisOrChildOf(actionContext, call.id)
                        );
                    }
                );
                recorder.resume();
                call.env = {
                    recorder
                };
            },
            onFinish(call, error) {
                const recorder = call.env?.recorder;
                if (!recorder) {
                    throw new Error("The call.env is corrupted");
                }
                call.env = undefined;
                recorder.stop();

                if (error === undefined) {
                    addUndoState(recorder, call.name);
                } else {
                    recorder.undo();
                }
            }
        });

        /**
         * This is used both internally to skip recording the undo and redo actions, and
         * to allow code using this middle ware to skip certain actions. 
         * 
         * The internal actions modify the recorded tree, so they should be skipped for 
         * purposes of undo. However, in order to support time travel that includes undo 
         * and redo we will need to record them somewhere, but perhaps that would be a 
         * separate middleware.
         * 
         * The `recordingDisabled` counter is used above in onStart in its recordPatches 
         * callback. Note that this is global setting. So if something starts skipping
         * recording that would be applied to all actions even un related asynchronous 
         * ones. 
         */
        const skipRecording = <T>(fn: () => T): T => {
            recordingDisabled++;
            try {
                return fn();
            } finally {
                recordingDisabled--;
            }
        };

        // I'd guess in our case we always want to include hooks. If a model makes some 
        // changes to its state when it is added to the tree during an action we'd want that
        // to be part of the undo stack.  
        //
        // TODO: however perhaps this setting is just for the initial action. So perhaps even
        // without this the creation of a model would be recorded by the recorder if it was
        // a done in a child action. So we should do some experimenation with middleware
        // the recorder and hooks.
        const middlewareDisposer = addMiddleware(targetStore, undoRedoMiddleware, includeHooks);

        // We might need an option to not add this disposer, but it seems it would generally
        // ge a good thing to do.
        addDisposer(targetStore, middlewareDisposer);

        const addUndoState = (recorder: IPatchRecorder, actionName: string) => {
            if (recorder.patches.length === 0) {
                // skip recording if patches is empty
                return;
            }

            // Instead of pushing to the history it might be better if this had a 
            // handler that was sent the new entry
            onRecorded({
                actionName,
                patches: recorder.patches,
                inversePatches: recorder.inversePatches
            });                    
        };

        return {
            middlewareDisposer,

            withoutUndo<T>(fn: () => T): T {
                return skipRecording(fn);
            },
            withoutUndoFlow(generatorFn: () => any) {
                return flow(function* __withoutUndoFlow__() {
                    recordingDisabled++;
                    try {
                        return yield* generatorFn();
                    } finally {
                        recordingDisabled--;
                    }
                });
            },
        };
    };
